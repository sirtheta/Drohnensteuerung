
Die Berechnung der aktuellen Orientation des Arduinos war eine grössere Herausforderung,
als wir dies im Vorfeld geplant hatten. Das Problem war hauptsächlich, dass das Gyroskop, welches auf dem SOC verbaut wird, nicht sehr genaue Werte ausgibt.

\subsubsection{Ursprüngliche Vorgehensweise}
Ursprünglich haben wir geplant, dass wir anhand der Gyroskop-Daten 
(Das Gyroskop gibt die aktuellen Winkelgeschwindigkeiten für jede Drehachse in Grad/Sekunde aus) 
die aktuellen Winkel wie folgt berechnen können:\\

Die aktuellen Winkel (\begin{math}CurrAngle_{x,y,z}\end{math}) werden zu begin mit 0 initialisiert, In der loop-Funktion des Arduinos werden die aktuellen Winkel mit dem Produkt aus der Winkelgeschwindikeit (\begin{math}v_{x,y,z}\end{math}) und dem Zeitdelta (\begin{math}\Delta{t}\end{math}) addiert.\\

\begin{math}
  CurrAngle_x = CurrAngle_x + v_x \Delta t  \\
  CurrAngle_y = CurrAngle_y + v_y \Delta t  \\
  CurrAngle_z = CurrAngle_z + v_z \Delta t  \\
\end{math}

Diese Methodik hat jedoch dazu geführt, dass die Winkel, durch die Ungenauigkeit der Daten, schon nach kurzer Zeit davon driften.
Um diese Problematik etwas in den Griff zu bekommen, haben wir eine Kalibrierungsfunktion implementiert, welche beim Starten des Arduinos durchloffen wird.
Zum Kalibrieren darf der Arduino nicht bewegt werden. In der Funktion werden nun 500 mal die Gyroskopdaten abgefragt.
Der Durchschnittswert dieser Daten wird anschliessend von zukünftigen Messungen abgezogen.
Mit Hilfe der Kalibrierungsfunktion konnten wir bereits etwas genauere Resultate erzielen, brauchbar waren diese jedoch  noch nicht.



\subsubsection{PID-Loop}
PID-Loops, PID-Controller oder auch PID Regler sind häufig in der Regelungstechnik anzutreffen.\\
Sie werden hauptsächlich eingesetzt um Fehler zu korrigieren und dabei das überschiessen und das daraus folgende Oszillieren zu verhindern.\\

\begin{figure}[H]
\centering
\begin{tikzpicture}
  \begin{axis}[
    xmin = 0,
    xmax = 8,
    ymin = -1,
    ymax = 1,
    xlabel={time},
    ylabel = {value}
    ]
    \addplot[color=red]
  coordinates {(0,0) (8,0) };
  \addlegendentry{Target}
  \addplot[smooth,blue]
  coordinates {(0,-1) (1,0.2) (2,-0.2) (3,0.2) (4,-0.2) (5,0.2) (6,-0.2) (7,0.2) (8,-0.2)};
  \addlegendentry{Error}
  \addplot[smooth,green]
  coordinates {(0,-1) (1,0.01) (2,-0.01) (3,0) (4,0) (5,0) (6,0) (7,0) (8,0)};
  \addlegendentry{Error (PID)}
  
  \end{axis}
  \end{tikzpicture}
  \caption{Regelung mit und ohne PID-Loop}
\end{figure}

In unserem Projekt verwenden wir für alle Drehachsen des Arduinos jeweils ein PID-Loop. 



\begin{figure}[H]
  \begin{center}
    \includegraphics[width=1\linewidth]{content/images/PID_Loop.png}
    \caption{PID Loop}
  \end{center}
\end{figure}


  
\subsubsection{PID-Algorythmus}
\begin{minipage}[l]{0.5\textwidth}
  \begin{math}
    Korrekturwert = K_p e(t) + K_i e_i \Delta{t} + \frac{K_d \Delta{e}}{\Delta{t}} \\
  \end{math} 
\end{minipage}
\begin{minipage}[r]{0.49\textwidth}
  \begin{table}[H]
    \centering
  \settowidth\tymin{Variablen}
  \setlength\extrarowheight{2pt}
  \begin{tabulary}{1.0\textwidth}{|L|L|}
    \hline
    \begin{math} K_p \end{math} & Proportional-Konstante\\
    \hline
    \begin{math} K_i \end{math} & Integral-Konstante\\
    \hline
    \begin{math} K_d \end{math} & Ableitung-Konstante\\
    \hline
    \begin{math} e(t) \end{math} & aktueller Fehler\\
    \hline
    \begin{math} \Delta{t} \end{math} & Zeit seit der letzten Korrektur\\
    \hline
    \begin{math} \Delta{e} \end{math} & Differenz des aktuellen und letzten Fehlers\\
    \hline
    \begin{math} e_i \end{math} & Fehlerintegral (\begin{math} \int_{0}^t e(t) \end{math})\\
    \hline
  \end{tabulary}
  \caption{Variablen Verzeichnis}
\end{table}
\end{minipage}

